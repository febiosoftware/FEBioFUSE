/*Generated by FEBio Studio 3.0.0*/

#include <FECore/FEModel.h>
#include "FECoupledSolver.h"
#include <FEBioXML/XMLReader.h>
#include <FEBioXML/xmltool.h>
#include <FEBioXML/FEBioImport.h>
#include <FECore/log.h>
#include <FECore/FEScalarValuator.h>
#include <FECore/FEModelParam.h>
#include <FECore/FEDomainMap.h>
#include <iostream>
#include <sstream>
using namespace std;

BEGIN_FECORE_CLASS(FECoupledSolver, FECoreTask)
	ADD_PARAMETER(m_version, "version")->SetFlags(FE_PARAM_ATTRIBUTE);
	ADD_PROPERTY(m_models, "models");
	ADD_PROPERTY(m_exchanges, "exchanges");
END_FECORE_CLASS();

static bool coupling_cb(FEModel* fem, unsigned int nwhen, void* data)
{
	FECoupledSolver* s = (FECoupledSolver*)data;
	return s->RunCoupling();
}

FECoupledSolver::FECoupledSolver(FEModel* fem) : FECoreTask(fem), m_exchanges(fem)
{
#ifndef NDEBUG
	fem->SetVerboseMode(true);
#endif
}

bool FECoupledSolver::Init(const char* szfile)
{
	if (!ParseControlFile(szfile))
	{
		std::cerr << "Failed to parse control file: " << szfile << std::endl;
		return false;
	}

	if (!InitModels())
	{
		std::cerr << "Failed to initialize models.\n";
		return false;
	}

	// get the primary FE model
	FEModel* fem = GetFEModel();

	// TODO: make any necessary changes to the model
	fem->AddCallback(coupling_cb, CB_UPDATE_TIME, this);

	// Then, initialize the model
	return fem->Init();
}

bool FECoupledSolver::Run()
{
	FEModel* fem = GetFEModel();

	// TODO: This function is called by FEBio and should execute the task's logic.
	//       To run the forward model, call FEModel::Solve()
	//       To reset the model, call FEModel::Reset()
	return fem->Solve();
}

bool FECoupledSolver::ParseControlFile(const char* szfile)
{
	// load control file
	if (szfile == nullptr) return false;

	XMLReader xml;
	if (!xml.Open(szfile)) return false;

	XMLTag tag;
	if (!xml.FindTag("febio_coupled_solver", tag))
	{
		xml.Close();
		return false;
	}

	if (fexml::readParameterList(tag, this) == false)
	{
		xml.Close();
		return false;
	}
	xml.Close();

	return true;
}

bool FECoupledSolver::InitModels()
{
	if (m_models.empty()) return true;

	FEModel* fem = GetFEModel(); // primary model
	m_models.SetPrimaryModel(fem);
	string primaryName = m_models.primaryModel.name;
	if (primaryName.empty() == false)
		fem->SetName(m_models.primaryModel.name);

	for (Model& mdl : m_models)
	{
		if (!mdl.InitModel())
		{
			std::cerr << "Failed to initialize model: " << mdl.name << std::endl;
			return false;
		}
	}

	// resolve couplings
	for (DataExchange& dex : m_exchanges)
	{
		if (!dex.InitExchange(m_models))
		{
			std::cerr << "Failed to initialize data exchange.\n";
			return false;
		}
	}

	// Now that we've been able to read them all in,
	// let's initialize them
	for (Model& mdl : m_models)
	{
		assert(mdl.fem);
		if (mdl.fem->Init() == false)
		{
			std::cerr << "Failed to initialize model :\"" << mdl.name << "\"\n";
			return false;
		}
	}

	FECoreKernel& fecore = FECoreKernel::GetInstance();
	string moduleName;

	// setup plot files
	for (Model& mdl : m_models)
	{
		FEBioPlotFile* xplt = new FEBioPlotFile(mdl.fem.get());

		moduleName = mdl.fem->GetModuleName();
		fecore.SetActiveModule(moduleName.c_str());

		string fileName = mdl.name + ".xplt";
		if (!xplt->Open(fileName.c_str()))
		{
			delete xplt;
			return false;
		}
		mdl.plt = std::shared_ptr<FEBioPlotFile>(xplt);
		mdl.plt->Write(0.f);
	}

	// restore correct module for the primary model
	moduleName = GetFEModel()->GetModuleName();
	fecore.SetActiveModule(moduleName.c_str());

	return true;
}

bool FECoupledSolver::RunCoupling()
{
	feLog("\nTransferring data from primary to secondary.\n");
	if (!m_exchanges.TransferData(DataExchange::Type::PRIMARY_TO_SECONDARY))
		return false;

	// solve the secondary models
	FETimeInfo& ti = GetFEModel()->GetTime();
	feLog("Running secondary models:\n");
	for (Model& mdl : m_models)
	{
		feLog("\tRunning model %s ...", mdl.name.c_str());
		bool b = mdl.RunModel(ti.currentTime);
		feLog(" %s\n", (b ? "SUCCESS" : "FAILED"));
		if (!b) return false;
	}

	feLog("\nTransferring data from secondary to primary.\n");
	if (!m_exchanges.TransferData(DataExchange::Type::SECONDARY_TO_PRIMARY))
		return false;

	return true;
}
